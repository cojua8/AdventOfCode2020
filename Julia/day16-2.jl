function process_file(file::AbstractString)
    io = eachline(file)

    # rules
    ticket_rules_list = String[]

    while !eof(io.stream)
        line = iterate(io)[1]
        if line == ""
            break
        end
        push!(ticket_rules_list, line)
    end

    # own ticket
    own_ticket = ""
    while true
        if iterate(io)[1] == "your ticket:"
            own_ticket = parse.(Int, split(iterate(io)[1], ','))
            break
        end
    end

    # nearby tickets
    while iterate(io)[1] != "nearby tickets:"
    end

    nearby_tickets = [parse.(Int, split(line, ',')) for line in io]

    return ticket_rules_list, own_ticket, nearby_tickets
end

function ticket_rules(rule_list::AbstractVector{T}) where T <: AbstractString
    rules = Dict{T,Function}()

    re = r"(.+): (\d+-\d+) or (\d+-\d+)"
    for rule in rule_list
        name, range1, range2 = match(re, rule).captures
        range1 = eval(Meta.parse(replace(range1, "-" => ":")))
        range2 = eval(Meta.parse(replace(range2, "-" => ":")))

        rules[name] = (n::Integer) -> n in range1 || n in range2
    end

    rules
end

"""
for every ticket value, checks if any of the conditions returns true.
if all conditions return false for a value, the ticket is invalid.
"""
function valid_tickets(rules::Dict{<:AbstractString,Function},
    tickets::Vector{<:Vector{<:Integer}})

    valid_tickets_list = filter(
        ticket -> all(v -> any(f -> f(v), values(rules)), ticket), tickets)

    return valid_tickets_list
end


function validity_matrix(rules::Dict{<:AbstractString,Function},
    tickets::Vector{<:Vector{<:Integer}})

    ticket_matrix = hcat(tickets...)
    # every column correspond to a function and every row corresponds to a
    # position
    vm = [all(f.(ticket_matrix), dims=2) for f in values(rules)]
    vm = hcat(vm...)

    return vm
end

"""
a position belongs to a field if it returns true to all values in that
position.
THIS IS NOT A GENERAL SOLUTION, and I don't know if this works with all
of the inputs generated by aoc team.
validity_matrix is a good start point for the general solution
"""
function infer_fields(rules::Dict{<:AbstractString,Function},
    tickets::Vector{<:Vector{<:Integer}})
    nrules = length(rules)
    vm = validity_matrix(rules, tickets)

    order = zeros(Int, nrules)
    foreach((v) -> order[v[2]] = v[1], enumerate(count(vm, dims=1)))

    inferred_fields = zeros(Int, nrules)
    current_vector = BitArray(zeros(Int, nrules))
    for i in order
        vector_difference = vm[:, i] .- current_vector

        inferred_fields[findfirst(vector_difference .== 1)] = i

        current_vector = vm[:, i]
    end

    return collect(keys(rules))[inferred_fields]
end


function main()
    ticket_rules_list, own_ticket, nearby_tickets = process_file(
        "Recursos/day16-input.txt")

    rules = ticket_rules(ticket_rules_list)

    valid_nearby_tickets = valid_tickets(rules, nearby_tickets)

    fields = infer_fields(rules, valid_nearby_tickets)

    own_ticket_with_field = Dict((k, v) for (k, v) in zip(fields, own_ticket))

    prod(v for (k, v) in own_ticket_with_field if occursin("departure", k))
end

main()
